# 链表的边界情况

1. 空： null
2. 一个链表：1 -> null
3. 两个链表：1 -> 1 -> null


1. 思考问题切入点/关键点
2. 形成解题初步思路
3. 思考如何将思路转化为代码

## 讨论关于删除链表中的所有重复元素问题

### 痛点：边界情况的条件判断让我很困扰，怎么能够做到滴水不漏，考虑所有情况/特殊到一般

### 思考时主要去想怎么得出来的这一步

### 问题切入点：

- 怎么确定重复元素的位置？
- 边界情况怎么处理？
- 就地删除还是创建新链表？

### 初步思路：

- 通过前后双指针去比较元素大小，从而确定重复元素的位置
- 边界情况主要去关注null值的产生
- 创建新链表比较合适且容易

### 思路 => 代码：

#### 切入点：

问题是有一般性和特殊性的两种情况，需要合理抉择先思考哪种情况？

__特殊 => 一般__  
__简单 => 复杂__ 

我们遵循着这个原则，那就很清晰了，从0个到1个再到2个再到3个再到n多个元素的链表。

#### 演化：

遵循初步思路指导

__首先0，1个元素的链表：__

肯定是不存在重复元素的，直接返回原链表即可

```
if (head == null || head.next == null) {
    return head;
}
```

__其次两个元素的链表：__

`l1 --> l2 --> null`

可以定义双指针了，即起始状态

```
p1 = head;
p2 = head.next;
```

想要比较每个元素大小，还需要遍历链表，目前无法写出遍历条件

原因：遍历一次，`p1.next` 会指向 `null`,还缺一种不指向 `null` 的情况

那么还需要三个元素的链表来进行思考

至此，遍历时可能遇到情况就齐备了，我们来写一下模版。

```
while(p1 != null){

    比较前后元素的大小
    以定位重复的元素
    
    重复：跳过重复的元素
    不重复: 拼接到新的链表中
    
    p1 = p1.next;
}
```

至此可以看出我们还未定义新的链表,下面补上定义

```
dummy = new Node;
p = dummy;
```

最后要返回的就是`dummy.next`

现在，我们要思考的是循环体内的模块

比较后分成重复与不重复两种情况，很明显是一个条件判断

条件判断该怎么写呢？

首先，思考哪种情况更少更容易编写：

自然是重复的情况比较容易写，因为`p1`不可能为`null`，因此比较的前提是`p1.next`不能为`null`，

那么`p1.next`为`null`的情况就要单拿出来思考。我们一步一步来

`p1.next != null` 时，正常比较大小即可，分出两种情况。
`p1.next == null` 时，该元素和后面元素一定不重复，但是和前面不好说，暂定。 但我们要尽量保证让他前面元素不可能与他重复。

下面写出代码模版

```
if(p1.next != null && p1.val == p1.next.val){

重复处理

}else{

不重复处理

}
```

写出条件判断后，我们可以看出，除了给出的条件情况，其余条件情况确实均为不重复的情况。

因此我们要保证重复处理后的p1指针要完全跳出重复元素部分

那么现在该怎么跳出重复部分呢？

已知：目前两个元素是重复的

未知：后面的元素存在情况

目标：让p1前进到非重复部分

遍历继续比较，跃然纸上的思路，但未知的情况确有些棘手。

我们要分类讨论一下：

遍历一次，p.next可能会有三种情况： 空，重复与不重复

我们的遍历结束条件依赖于双指针指向的值得比较，因此，可以得出遍历终止条件

`p1.next != null && p1.val != p1.next.val`

遍历终止时，可能会有一下几种情况：

1. `p1.next == null`, 此时前后值肯定不相等，但是p1所指仍为重复元素。
2. `p1.next != null`, 此时后面的值不相等，但是p1所指仍为重复元素。

写出代码

```
while(p1.next != null && p1.val != p1.next.val){
    p1 = p1.next;
}

# 
if(p1.next == null){
    p.next = null;
}

# 差一步跳出重复元素
p1 = p1.next;
```

跳出来之后的衔接是否合理呢？

合理，考虑了所有情况

之后补全非重复部分的代码

```
p.next = p1;
p = p.next;
p1 = p1.next;

```

最后加上返回语句，算是完成了。

我们给出最终的伪代码：

```

if (head == null || head.next == null) {
    return head;
}

p1 = head;
dummy = new Node;
p = dummy;

# 所有节点都要进入循环体
while (p1 != null) {
    if (p1.next != null && p1.val == p1.next.val){
        # 完全跳出重复元素部分，条件判断才合理
        while (p1.next != null && p1.val == p1.next.val) {
            
            p1 = p1.next;
        }
        
        if (p1.next == null){
            p.next = null;
        }
        p1 = p1.next;
    
    }else{
        p.next = p1;
        p = p.next;
        p1 = p1.next;
    }
    
}

return dummy.next;

```





边界情况的条件判断

分类讨论，特殊到一般，注意完整性。




















